<!DOCTYPE HTML>
<html lang="en" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Writing a client proxy - zbus: D-Bus for Rust made easy</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">1.</strong> Some D-Bus concepts</a></li><li class="chapter-item expanded "><a href="connection.html"><strong aria-hidden="true">2.</strong> Establishing connections</a></li><li class="chapter-item expanded "><a href="client.html" class="active"><strong aria-hidden="true">3.</strong> Writing a client proxy</a></li><li class="chapter-item expanded "><a href="server.html"><strong aria-hidden="true">4.</strong> Writing a server interface</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">zbus: D-Bus for Rust made easy</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/dbus2/zbus" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-gitlab"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<p><strong>Note</strong></p>
<p>This version of the book is based on older zbus 1.0 API. The 2.0 version of this book is available
<a href="https://dbus2.github.io/zbus/">here</a>.</p>
</blockquote>
<h1 id="writing-a-client-proxy"><a class="header" href="#writing-a-client-proxy">Writing a client proxy</a></h1>
<p>In this chapter, we are going to see how to make low-level D-Bus method calls. Then we are going to
dive in, and derive from a trait to make a convenient Rust binding. Finally, we will learn about
<em>xmlgen</em>, a tool to help us generate a boilerplate trait from the XML of an introspected service.</p>
<p>To make this learning “hands-on”, we are going to call and bind the cross-desktop notification
service (please refer to this
<a href="https://specifications.freedesktop.org/notification-spec/notification-spec-latest.html">reference</a>
document for further details on this API).</p>
<p>Let’s start by playing with the service from the shell, and notify the desktop with [<code>busctl</code>]<sup class="footnote-reference"><a href="#busctl">1</a></sup>:</p>
<pre><code class="language-bash">busctl --user call \
  org.freedesktop.Notifications \
  /org/freedesktop/Notifications \
  org.freedesktop.Notifications \
  Notify \
  susssasa\{sv\}i \
  "my-app" 0 "dialog-information" "A summary" "Some body" 0 0 5000
</code></pre>
<p><strong>Note</strong>: <code>busctl</code> has very good auto-completion support in bash or zsh.</p>
<p>Running this command should pop-up a notification dialog on your desktop. If it does not, your
desktop does not support the notification service, and this example will be less interactive.
Nonetheless you can use a similar approach for other services.</p>
<p>This command shows us several aspects of the D-Bus communication:</p>
<ul>
<li>
<p><code>--user</code>: Connect to and use the user/session bus.</p>
</li>
<li>
<p><code>call</code>: Send a method call message. (D-Bus also supports signals, error messages, and method
replies)</p>
</li>
<li>
<p><strong>destination</strong>: The name of the service (<code>org.freedesktop.Notifications</code>).</p>
</li>
<li>
<p><strong>object path</strong>: Object/interface path (<code>/org/freedesktop/Notifications</code>).</p>
</li>
<li>
<p><strong>interface</strong>: The interface name (methods are organized in interfaces, here
<code>org.freedesktop.Notifications</code>, same name as the service).</p>
</li>
<li>
<p><strong>method</strong>: The name of the method to call, <code>Notify</code>.</p>
</li>
<li>
<p><strong>signature</strong>: That <code>susssasa{sv}i</code> means the method takes 8 arguments of various types. ‘s’, for
example, is for a string. ‘as’ is for array of strings.</p>
</li>
<li>
<p>The method arguments.</p>
</li>
</ul>
<p>See <a href="https://www.freedesktop.org/software/systemd/man/busctl.html"><code>busctl</code></a> man page for more details.</p>
<h2 id="low-level-call-from-a-zbusconnection"><a class="header" href="#low-level-call-from-a-zbusconnection">Low-level call from a <code>zbus::Connection</code></a></h2>
<p>zbus <code>Connection</code> has a <code>call_method()</code> method, which you can use directly:</p>
<pre><pre class="playground"><code class="language-rust no_run">use std::collections::HashMap;
use std::error::Error;

use zbus::Connection;
use zvariant::Value;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let connection = Connection::new_session()?;

    let m = connection.call_method(
        Some("org.freedesktop.Notifications"),
        "/org/freedesktop/Notifications",
        Some("org.freedesktop.Notifications"),
        "Notify",
        &amp;("my-app", 0u32, "dialog-information", "A summary", "Some body",
          vec![""; 0], HashMap::&lt;&amp;str, &amp;Value&gt;::new(), 5000),
    )?;
    let reply: u32 = m.body().unwrap();
    dbg!(reply);
    Ok(())
}</code></pre></pre>
<p>Although this is already quite flexible, and handles various details for you (such as the message
signature), it is also somewhat inconvenient and error-prone: you can easily miss arguments, or give
arguments with the wrong type or other kind of errors (what would happen if you typed <code>0</code>, instead
of <code>0u32</code>?).</p>
<p>Instead, we want to wrap this <code>Notify</code> D-Bus method in a Rust function. Let’s see how next.</p>
<h2 id="trait-derived-proxy-call"><a class="header" href="#trait-derived-proxy-call">Trait-derived proxy call</a></h2>
<p>A trait declaration <code>T</code> with a <code>dbus_proxy</code> attribute will have a derived <code>TProxy</code> implemented
thanks to procedural macros. The trait methods will have respective <code>impl</code> methods wrapping the
D-Bus calls:</p>
<pre><pre class="playground"><code class="language-rust no_run">use std::collections::HashMap;
use std::error::Error;

use zbus::dbus_proxy;
use zvariant::Value;

#[dbus_proxy]
trait Notifications {
    /// Call the org.freedesktop.Notifications.Notify D-Bus method
    fn notify(&amp;self,
              app_name: &amp;str,
              replaces_id: u32,
              app_icon: &amp;str,
              summary: &amp;str,
              body: &amp;str,
              actions: &amp;[&amp;str],
              hints: HashMap&lt;&amp;str, &amp;Value&gt;,
              expire_timeout: i32) -&gt; zbus::Result&lt;u32&gt;;
}

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let connection = zbus::Connection::new_session()?;

    let proxy = NotificationsProxy::new(&amp;connection)?;
    let reply = proxy.notify("my-app", 0, "dialog-information", "A summary", "Some body",
                             &amp;[], HashMap::new(), 5000)?;
    dbg!(reply);

    Ok(())
}</code></pre></pre>
<p>A <code>TProxy</code> has a few associated methods, such as <code>new(connection)</code>, using the default associated
service name and object path, and <code>new_for(connection, service_name, object_path)</code> if you need to
specify something different.</p>
<p>This should help to avoid the kind of mistakes we saw earlier. It’s also a bit easier to use, thanks
to Rust type inference. This makes it also possible to have higher-level types, they fit more
naturally with the rest of the code. You can further document the D-Bus API or provide additional
helpers.</p>
<h3 id="properties"><a class="header" href="#properties">Properties</a></h3>
<p>Interfaces can have associated properties, which can be read or set with the
<code>org.freedesktop.DBus.Properties</code> interface. Here again, the <code>#[dbus_proxy]</code> attribute comes to the
rescue to help you. You can annotate a trait method to be a getter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use zbus::{dbus_proxy, Result};
</span><span class="boring">
</span>#[dbus_proxy]
trait MyInterface {
    #[dbus_proxy(property)]
    fn state(&amp;self) -&gt; Result&lt;String&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>state()</code> method will translate to a <code>"State"</code> property <code>Get</code> call.</p>
<p>To set the property, prefix the name of the property with <code>set_</code>.</p>
<p>For a more real world example, let’s try and read two properties from systemd’s main service:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::error::Error;
</span><span class="boring">use zbus::dbus_proxy;
</span><span class="boring">
</span>#[dbus_proxy(
    interface = "org.freedesktop.systemd1.Manager",
    default_service = "org.freedesktop.systemd1",
    default_path = "/org/freedesktop/systemd1"
)]
trait SystemdManager {
    #[dbus_proxy(property)]
    fn architecture(&amp;self) -&gt; zbus::Result&lt;String&gt;;
    #[dbus_proxy(property)]
    fn environment(&amp;self) -&gt; zbus::Result&lt;Vec&lt;String&gt;&gt;;
}

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let connection = zbus::Connection::new_session()?;

    let proxy = SystemdManagerProxy::new(&amp;connection)?;
    println!("Host architecture: {}", proxy.architecture()?);
    println!("Environment:");
    for env in proxy.environment()? {
        println!("  {}", env);
    }

    Ok(())
}</code></pre></pre>
<p>You should get an output similar to this:</p>
<pre><code class="language-none">Host architecture: x86-64
Environment variables:
  HOME=/home/zeenix
  LANG=en_US.UTF-8
  LC_ADDRESS=de_DE.UTF-8
  LC_IDENTIFICATION=de_DE.UTF-8
  LC_MEASUREMENT=de_DE.UTF-8
  LC_MONETARY=de_DE.UTF-8
  LC_NAME=de_DE.UTF-8
  LC_NUMERIC=de_DE.UTF-8
  LC_PAPER=de_DE.UTF-8
  LC_TELEPHONE=de_DE.UTF-8
  LC_TIME=de_DE.UTF-8
  ...
</code></pre>
<h3 id="signals"><a class="header" href="#signals">Signals</a></h3>
<p>Signals are like methods, except they don’t expect a reply. They are typically emitted by services
to notify interested peers of any changes to the state of the service. zbus provides you with an API
to register signal handler functions, and to receive and call them.</p>
<p>Let’s look at this API in action, with an example where we get our location from
<a href="https://gitlab.freedesktop.org/geoclue/geoclue/-/blob/master/README.md">Geoclue</a>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use zbus::{Connection, dbus_proxy, Result};
use zvariant::{ObjectPath, OwnedObjectPath};

#[dbus_proxy(
    default_service = "org.freedesktop.GeoClue2",
    interface = "org.freedesktop.GeoClue2.Manager",
    default_path = "/org/freedesktop/GeoClue2/Manager"
)]
trait Manager {
    fn get_client(&amp;self) -&gt; Result&lt;OwnedObjectPath&gt;;
}

#[dbus_proxy(
    default_service = "org.freedesktop.GeoClue2",
    interface = "org.freedesktop.GeoClue2.Client"
)]
trait Client {
    fn start(&amp;self) -&gt; Result&lt;()&gt;;
    fn stop(&amp;self) -&gt; Result&lt;()&gt;;

    #[dbus_proxy(property)]
    fn set_desktop_id(&amp;mut self, id: &amp;str) -&gt; Result&lt;()&gt;;

    #[dbus_proxy(signal)]
    fn location_updated(&amp;self, old: ObjectPath&lt;'_&gt;, new: ObjectPath&lt;'_&gt;) -&gt; Result&lt;()&gt;;
}

#[dbus_proxy(
    default_service = "org.freedesktop.GeoClue2",
    interface = "org.freedesktop.GeoClue2.Location"
)]
trait Location {
    #[dbus_proxy(property)]
    fn latitude(&amp;self) -&gt; Result&lt;f64&gt;;
    #[dbus_proxy(property)]
    fn longitude(&amp;self) -&gt; Result&lt;f64&gt;;
}
let conn = Connection::new_system().unwrap();
let manager = ManagerProxy::new(&amp;conn).unwrap();
let client_path = manager.get_client().unwrap();
let mut client = ClientProxy::new_for_path(&amp;conn, &amp;client_path).unwrap();
// Gotta do this, sorry!
client.set_desktop_id("org.freedesktop.zbus").unwrap();

client
    .connect_location_updated(move |_old, new| {
        let location = LocationProxy::new_for_path(&amp;conn, &amp;new);
        println!(
            "Latitude: {}\nLongitude: {}",
            location.latitude()?,
            location.longitude()?,
        );

        Ok(())
    })
    .unwrap();

client.start().unwrap();

// Wait till there is a signal that was handled.
while client.next_signal().unwrap().is_some() {}
<span class="boring">}</span></code></pre></pre>
<p>While the Geoclue’s D-Bus API is a bit involved, we still ended-up with a not-so-complicated (~60
LOC) code for getting our location. As you may’ve notice, we use a blocking call to wait for a
signal on one proxy. This works fine but in the real world, you would typically have many proxies
and you’d want to wait for signals from them all at once. Not to worry, zbus provides a way to wait
on <a href="https://docs.rs/zbus/1.5.0/zbus/struct.SignalReceiver.html">multiple proxies at once as well</a>.</p>
<p>Let’s make use of <code>SignalReceiver</code> and <code>zbus::fdo</code> API to make sure the client is actually started
by watching for <code>Active</code> property (that we must set to be able to get location from Geoclue)
actually getting set:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use zbus::{Connection, dbus_proxy, Result};
</span><span class="boring">use zvariant::{ObjectPath, OwnedObjectPath};
</span><span class="boring">
</span><span class="boring">#[dbus_proxy(
</span><span class="boring">    default_service = "org.freedesktop.GeoClue2",
</span><span class="boring">    interface = "org.freedesktop.GeoClue2.Manager",
</span><span class="boring">    default_path = "/org/freedesktop/GeoClue2/Manager"
</span><span class="boring">)]
</span><span class="boring">trait Manager {
</span><span class="boring">    fn get_client(&amp;self) -&gt; Result&lt;OwnedObjectPath&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[dbus_proxy(interface = "org.freedesktop.GeoClue2.Client")]
</span><span class="boring">trait Client {
</span><span class="boring">    fn start(&amp;self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    #[dbus_proxy(property)]
</span><span class="boring">    fn set_desktop_id(&amp;mut self, id: &amp;str) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    #[dbus_proxy(signal)]
</span><span class="boring">    fn location_updated(&amp;self, old: ObjectPath, new: ObjectPath) -&gt; Result&lt;()&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[dbus_proxy(
</span><span class="boring">    default_service = "org.freedesktop.GeoClue2",
</span><span class="boring">    interface = "org.freedesktop.GeoClue2.Location"
</span><span class="boring">)]
</span><span class="boring">trait Location {
</span><span class="boring">    #[dbus_proxy(property)]
</span><span class="boring">    fn latitude(&amp;self) -&gt; Result&lt;f64&gt;;
</span><span class="boring">    #[dbus_proxy(property)]
</span><span class="boring">    fn longitude(&amp;self) -&gt; Result&lt;f64&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">let conn = Connection::new_system().unwrap();
</span><span class="boring">let manager = ManagerProxy::new(&amp;conn).unwrap();
</span><span class="boring">let client_path = manager.get_client().unwrap();
</span><span class="boring">let mut client =
</span><span class="boring">    ClientProxy::new_for(&amp;conn, "org.freedesktop.GeoClue2", &amp;client_path);
</span><span class="boring">// Gotta do this, sorry!
</span><span class="boring">client.set_desktop_id("org.freedesktop.zbus").unwrap();
</span><span class="boring">
</span>// Everything else remains the same before this point.

let conn_clone = conn.clone();
client.connect_location_updated(move |_old, new| {
    let location = LocationProxy::new_for(
        &amp;conn_clone,
        "org.freedesktop.GeoClue2",
        &amp;new,
    )?;
    println!(
        "Latitude: {}\nLongitude: {}",
        location.latitude()?,
        location.longitude()?,
    );

    Ok(())
}).unwrap();

let props = zbus::fdo::PropertiesProxy::new_for(
    &amp;conn,
    "org.freedesktop.GeoClue2",
    &amp;client_path,
).unwrap();
props.connect_properties_changed(|iface, changed, _| {
    for (name, value) in changed.iter() {
        println!("{}.{} changed to `{:?}`", iface, name, value);
    }

    Ok(())
}).unwrap();

let mut receiver = zbus::SignalReceiver::new(conn);
receiver.receive_for(&amp;client);
receiver.receive_for(&amp;props);

client.start().unwrap();

// 3 signals will be emitted, that we handle
let mut num_handled = 0;
while num_handled &lt; 3 {
    if receiver.next_signal().unwrap().is_none() {
        num_handled += 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="generating-the-trait-from-an-xml-interface"><a class="header" href="#generating-the-trait-from-an-xml-interface">Generating the trait from an XML interface</a></h2>
<p>The <code>zbus_xmlgen</code> crate provides a <a href="https://crates.io/crates/zbus_xmlgen">developer-friendly tool</a>, that can generate Rust traits from a
given D-Bus introspection XML for you.</p>
<p><strong>Note:</strong> This tool should not be considered a drop-in Rust-specific replacement for similar tools
available for low-level languages, such as <a href="https://developer.gnome.org/gio/stable/gdbus-codegen.html"><code>gdbus-codegen</code></a>. Unlike those tools, this is only meant
as a starting point to generate the code, once. In many cases, you will want to tweak the generated
code.</p>
<p>The tool can be used to generate rust code directly from a D-Bus service running on our system:</p>
<pre><code class="language-bash">zbus-xmlgen --session \
  org.freedesktop.Notifications \
  /org/freedesktop/Notifications
</code></pre>
<p>Alternatively you can also get the XML interface from a different source and use it to generate the
interface code. Some packages may also provide the XML directly as an installed file, allowing it to
be queried using <a href="https://www.freedesktop.org/wiki/Software/pkg-config/"><code>pkg-config</code></a>, for example.</p>
<p>We can fetch the XML interface of the notification service, using the <code>--xml-interface</code> option of
the <code>busctl</code><sup class="footnote-reference"><a href="#busctl">1</a></sup> command. This option was introduced to <code>busctl</code> in systemd v243.</p>
<pre><code class="language-bash">busctl --user --xml-interface introspect \
  org.freedesktop.Notifications \
  /org/freedesktop/Notifications
</code></pre>
<p>You should get a similar output:</p>
<pre><code class="language-xml">&lt;!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
                      "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd"&gt;
&lt;node&gt;
  &lt;!-- other interfaces omitted --&gt;
  &lt;interface name="org.freedesktop.Notifications"&gt;
    &lt;method name="Notify"&gt;
      &lt;arg type="s" name="arg_0" direction="in"&gt;
      &lt;/arg&gt;
      &lt;arg type="u" name="arg_1" direction="in"&gt;
      &lt;/arg&gt;
      &lt;arg type="s" name="arg_2" direction="in"&gt;
      &lt;/arg&gt;
      &lt;arg type="s" name="arg_3" direction="in"&gt;
      &lt;/arg&gt;
      &lt;arg type="s" name="arg_4" direction="in"&gt;
      &lt;/arg&gt;
      &lt;arg type="as" name="arg_5" direction="in"&gt;
      &lt;/arg&gt;
      &lt;arg type="a{sv}" name="arg_6" direction="in"&gt;
      &lt;/arg&gt;
      &lt;arg type="i" name="arg_7" direction="in"&gt;
      &lt;/arg&gt;
      &lt;arg type="u" name="arg_8" direction="out"&gt;
      &lt;/arg&gt;
    &lt;/method&gt;
    &lt;method name="CloseNotification"&gt;
      &lt;arg type="u" name="arg_0" direction="in"&gt;
      &lt;/arg&gt;
    &lt;/method&gt;
    &lt;method name="GetCapabilities"&gt;
      &lt;arg type="as" name="arg_0" direction="out"&gt;
      &lt;/arg&gt;
    &lt;/method&gt;
    &lt;method name="GetServerInformation"&gt;
      &lt;arg type="s" name="arg_0" direction="out"&gt;
      &lt;/arg&gt;
      &lt;arg type="s" name="arg_1" direction="out"&gt;
      &lt;/arg&gt;
      &lt;arg type="s" name="arg_2" direction="out"&gt;
      &lt;/arg&gt;
      &lt;arg type="s" name="arg_3" direction="out"&gt;
      &lt;/arg&gt;
    &lt;/method&gt;
    &lt;signal name="NotificationClosed"&gt;
      &lt;arg type="u" name="arg_0"&gt;
      &lt;/arg&gt;
      &lt;arg type="u" name="arg_1"&gt;
      &lt;/arg&gt;
    &lt;/signal&gt;
    &lt;signal name="ActionInvoked"&gt;
      &lt;arg type="u" name="arg_0"&gt;
      &lt;/arg&gt;
      &lt;arg type="s" name="arg_1"&gt;
      &lt;/arg&gt;
    &lt;/signal&gt;
  &lt;/interface&gt;
&lt;/node&gt;
</code></pre>
<p>Save the output to a <code>notify.xml</code> file. Then call:</p>
<pre><code class="language-bash">zbus-xmlgen notify.xml
</code></pre>
<p>This will give back effortlessly the corresponding Rust traits boilerplate
code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use zbus::dbus_proxy;
</span><span class="boring">
</span>#[dbus_proxy(interface = "org.freedesktop.Notifications")]
trait Notifications {
    /// CloseNotification method
    fn close_notification(&amp;self, arg_0: u32) -&gt; zbus::Result&lt;()&gt;;

    /// GetCapabilities method
    fn get_capabilities(&amp;self) -&gt; zbus::Result&lt;Vec&lt;String&gt;&gt;;

    /// GetServerInformation method
    fn get_server_information(&amp;self) -&gt; zbus::Result&lt;(String, String, String, String)&gt;;

    /// Notify method
    fn notify(
        &amp;self,
        arg_0: &amp;str,
        arg_1: u32,
        arg_2: &amp;str,
        arg_3: &amp;str,
        arg_4: &amp;str,
        arg_5: &amp;[&amp;str],
        arg_6: std::collections::HashMap&lt;&amp;str, zvariant::Value&gt;,
        arg_7: i32,
    ) -&gt; zbus::Result&lt;u32&gt;;

    /// ActionInvoked signal
    #[dbus_proxy(signal)]
    fn action_invoked(&amp;self, arg_0: u32, arg_1: &amp;str) -&gt; zbus::Result&lt;()&gt;;

    /// NotificationClosed signal
    #[dbus_proxy(signal)]
    fn notification_closed(&amp;self, arg_0: u32, arg_1: u32) -&gt; zbus::Result&lt;()&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>It should be usable as such. But you may as well improve a bit the naming of the arguments, use
better types (using <code>BitFlags</code>, structs or other custom types), add extra documentation, and other
functions to make the binding more pleasing to use from Rust.</p>
<p>For example, the generated <code>GetServerInformation</code> method can be improved to a nicer version:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use serde::{Serialize, Deserialize};
</span><span class="boring">use zvariant::derive::Type;
</span><span class="boring">use zbus::dbus_proxy;
</span><span class="boring">
</span>#[derive(Debug, Type, Serialize, Deserialize)]
pub struct ServerInformation {
    /// The product name of the server.
    pub name: String,

    /// The vendor name. For example "KDE," "GNOME," "freedesktop.org" or "Microsoft".
    pub vendor: String,

    /// The server's version number.
    pub version: String,

    /// The specification version the server is compliant with.
    pub spec_version: String,
}

trait Notifications {
    /// Get server information.
    ///
    /// This message returns the information on the server.
    fn get_server_information(&amp;self) -&gt; zbus::Result&lt;ServerInformation&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>You can learn more from the zbus-ify <a href="https://github.com/dbus2/zbus/tree/main/zbus_polkit#readme">binding of
PolicyKit</a>, for example, which was
implemented starting from the <em>xmlgen</em> output.</p>
<p>There you have it, a Rust-friendly binding for your D-Bus service!</p>
<div class="footnote-definition" id="busctl"><sup class="footnote-definition-label">1</sup>
<p><code>busctl</code> is part of <a href="https://www.freedesktop.org/wiki/Software/systemd/"><code>systemd</code></a>.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="connection.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="server.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="connection.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="server.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
